Jonas: Bu bölüm nesne yönelimli programlama hakkında ve bu ders bu programlama paradigmasına çok genel, üst düzey bir bakış olacak. Bu yüzden nesne yönelimli programlamanın ne olduğu, genel olarak nasıl çalıştığı ve dört temel ilkesi hakkında konuşacağız. Dolayısıyla bu gerçekten önemli ve değerli bir konferans olacak. Öyleyse başlayalım. Peki, öncelikle nesne yönelimli programlama nedir? Nesne yönelimli programlama ya da kısaca OOP, nesne kavramına dayanan bir programlama paradigmasıdır. Paradigma ise basitçe kodun tarzı, yani kodu nasıl yazdığımız ve düzenlediğimiz anlamına gelir. Artık nesneleri modellemek, yani bir kullanıcı veya yapılacaklar listesi öğesi gibi gerçek dünyanın yönlerini ya da bir HTML bileşeni veya bir tür veri yapısı gibi daha soyut özellikleri tanımlamak için kullanıyoruz. Şimdi, zaten bildiğimiz gibi, nesneler özellik olarak adlandırdığımız verileri ve ayrıca yöntem olarak adlandırdığımız kodları içerebilir. Dolayısıyla, nesneleri kullanarak tüm verileri ve ilgili davranışları tek bir büyük blokta topladığımızı söyleyebiliriz. Yani yine veri ve buna karşılık gelen davranış. Bu da doğrudan veriler üzerinde hareket etmeyi son derece kolaylaştırır. Bloklardan bahsetmişken, nesnelerin tam olarak böyle olması gerekiyor. Nesne yönelimli programlama yerine kullanacağım kısaltma olan OOP'de. Tamam. Yani OOP'de nesneler, kendi başlarına küçük uygulamalar gibi kendi kendine yeten kod parçaları veya kod bloklarıdır. Daha sonra bu nesneleri uygulamalarımızın yapı taşları olarak kullanıyor ve nesnelerin birbirleriyle etkileşime girmesini sağlıyoruz. Şimdi bu etkileşimler, API olarak da adlandırdığımız genel bir arayüz aracılığıyla gerçekleşir. Bu arayüz temel olarak nesnelerin dışındaki bir kodun erişebileceği ve nesneyle iletişim kurmak için kullandığımız bir grup yöntemdir. Tamam. Şimdi biraz nefes alalım çünkü tüm bunlar kulağa biraz soyut geliyor, değil mi? Ama endişelenme. Bu bölüm boyunca bu kavramları kod kullanarak geliştirmeye başladığımızda daha anlamlı hale gelecektir. Ama her neyse, OOP aslında neden var? Bu paradigma, kodu daha esnek ve bakımı daha kolay hale getirecek şekilde düzenlemek amacıyla geliştirilmiştir. Dolayısıyla, OOP'den önce, birden fazla fonksiyonda veya hatta herhangi bir yapı olmaksızın global kapsamda toplanmış bir grup kodumuz olabilir. Ve bu özel çılgın kod tarzı, genellikle spagetti kodu olarak adlandırdığımız şeydir ve spagetti kodu, büyük kod tabanlarını korumayı ve buna yeni işlevler eklemeyi çok zorlaştırır. Dolayısıyla OOP fikri temelde bu soruna bir çözüm olarak ortaya çıkmıştır. Ve görünüşe göre işe yaradı çünkü bugün OOP, büyük ölçekli yazılım mühendisliğinde muhtemelen en popüler ve en yaygın kullanılan programlama paradigmasıdır. Şimdi, OOP kesinlikle düzenli ve sürdürülebilir kod yazmanın tek yolu değildir. Aslında, giderek daha popüler hale gelen birçok paradigma var ve bunlardan biri de fonksiyonel programlama. Ve fonksiyonel programlama, temelde spagetti koddan kaçınarak aynı hedefe ulaşmamızı sağlar. Söylediğim gibi, kursun ilerleyen bölümlerinde fonksiyonel programlama hakkında konuşacağız ve bunu nesne yönelimli programlama ile karşılaştıracağız. Ancak şimdilik OOP'ye odaklanalım. Şimdi, aslında nesneleri kullanmak bu noktada bizim için yeni bir şey değil, değil mi? Onları her zaman kullanıyoruz. Ancak, şimdiye kadar nesneleri temelde yalnızca gevşek veri koleksiyonları olarak ve birbirleriyle etkileşime girmelerini sağlamadan kullandık. Ayrıca, nesneleri programlı olarak oluşturmanın bir yolu yoktu. Şimdiye kadar yaptığımız tek şey basit nesne değişmezleri kullanmaktı, ancak OOP'de aslında kodumuzdan yeni nesneler üretmenin, yani yaratmanın bir yoluna ihtiyacımız var. Geleneksel OOP'de bunu yapmak için sınıf adı verilen bir şey kullanırız. Bir sınıfı, daha sonra sınıfta açıklanan kurallara göre yeni nesneler oluşturmak için kullanılabilecek bir plan olarak düşünebilirsiniz. Yani tıpkı mimarın bir evi tam olarak planlamak ve tanımlamak için bir plan geliştirdiği bir mimarlık gibi. Ancak plan aslında sadece soyut bir plandır, bir dizi kural gibi, ama gerçekten dokunabileceğiniz somut bir şey değildir. Ancak bu taslaktan yola çıkarak gerçek dünyada pek çok gerçek ev inşa edilebilir. Derslerde de durum aynı. Şimdi örnek olarak bu kurgusal kullanıcı sınıfına bir göz atalım. Kurgusal diyorum çünkü bu gerçek JavaScript sözdizimi değildir. Tamam. Çünkü JavaScript aslında burada açıkladığım gibi gerçek sınıfları desteklemiyor. JavaScript'te de bir sınıf sözdizimimiz var, ancak yine de burada size göstereceğimden biraz farklı çalışıyor. Bununla birlikte, nesneleri bir tür taslaktan yaratma fikri hala sahip olunması gereken çok yararlı bir zihinsel modeldir. Çünkü genel anlamda, JavaScript de dahil olmak üzere tüm dillerde OOP hala bu şekilde çalışmaktadır. İşte size bunu burada göstermemin nedeni budur, yani kavramsal bir genel bakış olarak ve bunu zihinsel bir model olarak almanız için. Her neyse, buradaki kurgusal sınıfımıza geri dönersek, bir kullanıcı adı, bir parola ve bir e-postası olan bir kullanıcıyı tanımladığını görebiliriz. Yani bir kullanıcı hakkındaki verilerin bir açıklamasıdır, ancak henüz verinin kendisi değildir. Çünkü unutmayın, sınıf aslında sadece bir plandır ve bir plan henüz gerçek dünya verilerini içermez. Öte yandan, verilerle ilişkilendirilen davranışlara da sahibiz. Ve bu durumda, bu sadece bir oturum açma yöntemi ve mesaj gönderme yöntemidir. Son slaytta öğrendiğimiz gibi, bu sınıfta bir kullanıcıyla ilgili her şey vardır. Yani veriler ve davranışlar tek bir güzel, bağımsız blokta toplanmıştır. Ama şimdi bu sınıfı kullanalım ve bu sınıftan yeni bir nesne oluşturalım. Ve şimdi kullanıcı ve nesne hakkında gerçek verilere sahip olduğumuzu ve sınıfta olduğu gibi verilerin sadece bir açıklamasına sahip olmadığımızı görüyorsunuz, yani planda. Şimdi bir sınıf aracılığıyla oluşturulan tüm nesnelere o sınıfın örnekleri diyoruz. Yani yine, bir örnek, kodumuzda kullanabileceğimiz, bir sınıftan yaratılmış gerçek bir nesnedir ve bir sınıfın kendisi bir nesne değildir. Tamam. Daha önceki plan benzetmesine geri dönersek, bu örnek, mimar tarafından oluşturulan soyut plandan yaratılan gerçek bir ev gibidir. Ve bunun güzelliği, artık bu sınıfı uygulamamızda ihtiyaç duyduğumuz kadar çok örnek oluşturmak için kullanabilmemizdir. Tıpkı tek bir plandan birden fazla ev inşa edebilmemiz gibi, değil mi? Ve tüm bu örnekler, yani bu nesneler, elbette içlerinde farklı verilere sahip olabilir, ancak hepsi aynı işlevselliği paylaşır; bu da oturum açmak ve mesaj göndermektir. Tamam. Artık bu sınıflardan nesneler üretmek için sınıflar oluşturabileceğimizi biliyoruz. Sınıfların nasıl çalıştığını biliyoruz, ancak bir sonraki mantıklı soru şu: Bir sınıfı gerçekte nasıl tasarlarız? Ya da başka bir deyişle, gerçek dünya verilerini sınıflar halinde nasıl modelleyebiliriz? Yani bu sorular tıpkı bir mimarlık öğrencisinin "Bir evi nasıl planlar ve tasarlarız?" sorusuna benziyor. Ve bu tabii ki çok güzel bir soru. Tahmin edebileceğiniz gibi bu sorunun cevabı pek de kolay değil. Dolayısıyla sınıfları tasarlamanın tek bir doğru yolu yoktur. Bununla birlikte, iyi bir sınıf uygulaması için bize rehberlik edebilecek dört temel ilke vardır. Bu ilkeler ise soyutlama, kapsülleme, kalıtım ve çok biçimliliktir. Ve bunlar aslında OOP dışında da kullanılabilecek tekniklerdir, ancak bu bağlamda özellikle önemlidirler. Şimdi her birine daha ayrıntılı bir şekilde göz atalım. Bunlardan ilki soyutlamadır. Ve soyutlama temelde önemli olmayan ayrıntıları görmezden gelmek veya gizlemek anlamına gelir. Bu, uygulamamız için gerçekten önemli olmayan ayrıntılarla uğraşmak yerine, uyguladığımız her neyse genel bir bakış açısı elde etmemizi sağlar. Diyelim ki bir kullanıcının kullanması için bir telefon geliştiriyoruz. Bu kod olarak pek bir anlam ifade etmese de yine de harika bir örnek ve benzetmedir. Yani soyutlama olmadan sınıfımızı, telefonun sıcaklığını ve voltajını doğrulamak, titreşim motorunu veya hoparlörü açmak ve diğer düşük seviyeli ayrıntılar gibi tüm dahili şeyler dahil olmak üzere telefonla ilgili her şeyi içerecek şekilde tasarlayabiliriz. Ancak bir telefonla etkileşime giren bir kullanıcı olarak, tüm bu ayrıntılara gerçekten ihtiyacımız var mı? Sanırım değil. Değil mi? Yani gerçekte, gerçek bir telefonla etkileşime girdiğimizde, tüm bu ayrıntılar kullanıcı olarak bizden soyutlanmıştır. Ve elimizde kalan tek şey, temelde yalnızca ana ekran düğmesini, ses düğmelerini ve ekranı kullanarak etkileşimde bulunduğumuz basit bir telefon. Diğer her şey gitti çünkü bir kullanıcı olarak buna ihtiyacımız yok. Böylece telefon, içinde neler olup bittiğini göremediğimiz bir tür kara kutu gibi çalışır. Şimdi, elbette, dahili olarak telefonun hala titreşmesi, voltajı ölçmesi veya hoparlörü açması gerekiyor, ancak bu ayrıntıları kullanıcıdan gizleyebiliriz. Soyutlamanın anlamı da tam olarak budur. Şimdi, son slayttaki kullanıcı örneğine geri dönersek, bir kullanıcının telefon numarasını, posta adresini, saç rengini, ayakkabı numarasını ve uygulamamızda ihtiyaç duymayabileceğimiz tonlarca başka şeyi uygulayabiliriz. Bu yüzden bu ayrıntıları görmezden geliyoruz. Şimdi, soyutlama sadece OOP'de değil, genel olarak programlamada gerçekten önemlidir. Aslında, her zaman soyutlamalar yaratır ve kullanırız. Örneğin, her zaman kullandığımız olay dinleyicisi ekle işlevini ele alalım. Perde arkasında tam olarak nasıl çalıştığını gerçekten biliyor muyuz? Biz bilmiyoruz. Peki umurumuzda mı? Hayır, pek sayılmaz. Değil mi? Ve buna gerek de yok çünkü bir kez daha, tam olarak nasıl çalıştığına dair alt düzey detaylar bizden gizlendi. Biz sadece kullanıcıyız. Ve böylece bu işlevi tamamen anlamadan ve kendimiz uygulamak zorunda kalmadan basitçe kullanabiliriz. Yani bu soyutlamadır ve aslında bir sonraki ilke olan kapsülleme ile birleşir. Kapsülleme temel olarak bazı özelliklerin ve yöntemlerin sınıfın dışından erişilememesi için sınıfın içinde özel tutulması anlamına gelir. Bununla birlikte, bazı yöntemler elbette API dediğimiz genel bir arayüz olarak gösterilebilir. Ve dersin başında nesneler arasındaki etkileşimlerin genel bir arayüz aracılığıyla gerçekleştiğini söylerken kastettiğim şey de tam olarak buydu. Daha önceki kullanıcı örneğimize dönecek olursak, özel özellikler kavramsal olarak şöyle görünebilir. Ve yine, burada varsayımsal konuşuyorum çünkü bu private anahtar sözcüğü aslında JavaScript'te mevcut değil. Ancak zaten bildiğimiz gibi, dış kod artık bu özelliklere erişemez. Ancak, sınıf içinde hala erişilebilir durumdadırlar. Örneğin, oturum açma yönteminde parola elbette gereklidir, değil mi? Ve böylece onu kullanabiliriz. Ve bu kritik özelliklerin bu şekilde güzelce kapsüllenmesini sağlayarak, harici kodun bu dahili durumu yanlışlıkla değiştirmesini önlüyoruz. Bu arada, state terimi basitçe bir nesnenin verilerini ifade eder. Tamam. Her neyse, bu gerçekten önemlidir çünkü harici kodun dahili durumu doğrudan manipüle etmesine izin vermek, özellikle büyük kod tabanlarında ve geliştirici ekiplerinde birçok hataya neden olabilir. Şimdi, gördüğünüz gibi, burada bir de özel yöntem var, spam kontrol yöntemi. Yine, bir sınıfın dışından erişilemez, ancak bir yorumun spam olup olmadığını kontrol etmek için dahili olarak kullanılır. Dolayısıyla, sınıfın dışında başka hiç kimsenin bu yöntemi kullanamamasını istiyoruz ve bu yüzden temelde bunu genel arayüzün bir parçası yapmıyoruz. Yani genel arayüz aslında özel olmayan, yani kapsüllenmemiş tüm yöntemlerdir. Bu nedenle, yöntemleri özel yapmak, bu yöntemlerden bazılarına güvenebilecek olan dışarıdan gelen kodu bozmadan kodumuzu değiştirmemizi kolaylaştırır. Örneğin, spam kontrol yöntemi herkese açık olsaydı, kodumuzun herhangi bir yerinde kullanılabilirdi. Ve daha sonra yöntemin uygulamasını değiştirirsek, bu, ona dayanan kodu bozabilir. Bu da yine hataların ve spagetti kodun önlenmesine yardımcı olur. Ve gerçekten bu sadece bir teori değil, bu gerçek bir pratik senaryo. Pekala. Dolayısıyla, kapsülleme ve özel yöntem ve özelliklerin var olmasının gerçek bir nedeni vardır. Özet olarak, her zaman durum ve yöntemlerimizin çoğunu güzel bir şekilde kapsüllemeyi ve az önce açıkladığım nedenlerden dolayı yalnızca temel yöntemleri herkese açık bırakmayı hedeflemeliyiz. Sırada miras var. Diyelim ki kullanıcı ve yönetici anlamına gelen admin olmak üzere iki sınıfımız var. Ve gördüğümüz gibi, aslında pek çok ortak noktaları var. Aslında admin, kullanıcının sahip olduğu tüm özelliklere ve yöntemlere sahiptir. Değil mi? Ve bu aslında mantıklı çünkü düşünürseniz, bir yönetici aynı zamanda bir kullanıcıdır. Örneğin, bir yöneticinin de bir parolaya ve e-postaya ihtiyacı vardır ve onun da oturum açması gerekir. Ancak, sınıflarımızı bu şekilde, yani iki ayrı kimlik olarak tasarlarsak, çok sayıda yinelenen kodla karşılaşırız ve bunun kötü olduğunu zaten biliyoruz. Değil mi? Ama işte miras burada devreye giriyor. Dolayısıyla OOP'de, user ve admin gibi birbiriyle yakından ilişkili iki sınıfımız olduğunda, bir sınıfın diğerinden miras almasını sağlayabiliriz. Böylece bir ana sınıfımız ve bir çocuk sınıfımız olacak ve çocuk sınıfı ana sınıfı genişletecektir. Tamam, harika. Peki tüm bunlar aslında ne anlama geliyor? Aslında oldukça sezgisel olduğunu düşünüyorum. Yani tıpkı sizin bir çocuk olarak ebeveynlerinizin bazı özelliklerini miras almış olmanız gibi, bir çocuk sınıf da tüm özellikleri ve yöntemleri ebeveyn sınıfından miras alır. Şimdi, daha resmi bir ifadeyle, kalıtım belirli bir sınıfın tüm özelliklerini ve yöntemlerini bir alt sınıf için kullanılabilir hale getirir ve tabii ki bu iki sınıf arasında bir hiyerarşi oluşturur. Bunun amacı, her iki sınıf için de ortak olan mantığı yeniden kullanmaktır. Bu durumda, hem yöneticinin hem de kullanıcının oturum açması gerekir. Bu nedenle, bu mantığı iki kez yazmak yerine, oturum açma yöntemini üst sınıf olan user'dan alt sınıf olan admin'e devralmak daha mantıklıdır. Elbette bir alt sınıf da kendi yöntemlerine ve özelliklerine sahip olabilir. Yani günün sonunda, alt sınıf ebeveyninden bazı yöntem ve özelliklere sahip olurken, bazılarını da kendisi kullanır. Dolayısıyla, yöneticinin de bir kullanıcı olduğunu söyleyebiliriz, ancak temelde genişletilmiş bir kullanıcı, yani bazı ek işlevlerle. Tamam. Ve son olarak, son ilke çok biçimliliktir. Ve polimorfizm kulağa biraz garip geliyor, çünkü Yunanca'dan geliyor ve kelimenin tam anlamıyla "birçok şekil" anlamına geliyor. Şimdi, OOP bağlamında, basit bir ifadeyle, çok biçimlilik, bir alt sınıfın bir üst sınıftan miras aldığı bir yöntemin üzerine yazabileceği anlamına gelir. Ve işte yine kullanıcı ve yönetici sınıflarımız. Ama şimdi üçüncü bir sınıfımız daha var, o da yazar. Şimdi admin ve author gerçekten de sadece özel kullanıcı türleridir ve bu yüzden her ikisinin de user sınıfından miras alması mantıklıdır, tıpkı son slaytta incelediğimiz gibi. Bu nedenle, tüm özellikleri ve yöntemleri kullanıcı sınıfından miras alırlar, ancak şimdi oturum açma yöntemine odaklanacağız. Diyelim ki bir yönetici farklı türde bir oturum açma yöntemine ihtiyaç duyuyor. Örneğin, iki faktörlü kimlik doğrulaması olan daha güvenli bir tane. Ve diyelim ki yazarlar için de özel bir oturum açma yöntemine ihtiyacımız var. Peki onlara nasıl farklı giriş yöntemleri sunabiliriz? Aslında oldukça basit. Her sınıfta sadece login olarak da adlandırılan yeni bir yöntem yazıyoruz. Ve sonra, çok biçimliliğe göre, bu oturum açma yöntemi, kullanıcı sınıfından miras alınan oturum açma yönteminin üzerine yazılacaktır. Ve aslında hepsi bu. Polimorfizm hakkında bilmeniz gereken tek şey bu. Ve aslında bu, nesne yönelimli programlamaya giriş bölümünü tamamlıyor. Bu yüzden burada çok fazla şey olduğunu biliyorum, bu yüzden bu bölümde ilerlemeden önce her şeyi anladığınızdan emin olun. Şimdi sırada, nesne yönelimli programlamanın JavaScript'te gerçekte nasıl göründüğü hakkında konuşacağız. Çünkü başta da söylediğim gibi burada sınıflar ve örneklerle anlattığımdan biraz daha farklı bir şekilde uygulanıyor. Bunu anlamak hala çok önemlidir, ancak bir sonraki videoda JavaScript'in bunu nasıl yaptığını göreceğiz.