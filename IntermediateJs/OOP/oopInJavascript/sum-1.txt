
Son derste, sınıflar ve bu sınıflardan oluşturulan örneklerle klasik Nesne Yönelimli Programlama modelinden bahsetmiştik. Ve unutmayın, bir sınıf, teorik bir plan olan ve gerçek dünyada birçok ev inşa etmek için kullandığımız bir plan gibidir. Ve aynı şekilde, teorik sınıf, örnek olarak adlandırılan ve daha sonra cout'umuzda kullanabileceğimiz gerçek nesneler oluşturmak için kullanılabilir. Ve bu örnek oluşturma işlemine örnekleme denir. Daha önce JavaScript'te işlerin biraz farklı yürüdüğünü söylemiştim. Peki neden size ilk olarak sınıflardan ve örneklerden bahsettim? Bunun nedeni, JavaScript'te benzer kavramlara sahip olmamız ve bu nedenle öncelikle sınıf örneği modelini anlamanın çok yararlı olmasıdır. Ayrıca, birçok kişi bu terminolojiyi sadece JavaScript bağlamında kullanmaktadır.
 e son olarak, JavaScript sözdiziminin kendisi de bu terimlerden bazılarını kullanır; örneğin, örnekler. Bu nedenle, bir sınıfın ne olduğunu ve bir örneğin ne olduğunu gerçekten bilmeniz gerekir. Şimdi, her neyse, OOP JavaScript'te gerçekte nasıl çalışır? JavaScript'te prototip adı verilen bir şey vardır ve JavaScript'teki tüm nesneler belirli bir prototip nesnesine bağlıdır. Bu yüzden her nesnenin bir prototipi olduğunu söylüyoruz. Ve işte sihir geliyor. Dolayısıyla, prototip nesne, bu prototipe bağlı tüm nesnelerin erişebileceği ve kullanabileceği yöntemler ve özellikler içerir. Ve bu davranış genellikle prototip kalıtım olarak adlandırılır. Dolayısıyla, prototip kalıtım, belirli bir prototip nesneye bağlı olan tüm nesnelerin bu prototip üzerinde tanımlanan yöntemleri ve özellikleri kullanabileceği anlamına gelir. Yani temel olarak, nesneler prototipten metotları ve özellikleri miras alırlar, bu mekanizmaya prototip kalıtım denmesinin nedeni de budur. Bu kalıtımın aslında son derste bahsettiğimiz kalıtımdan farklı olduğunu unutmayın. Yani bu bir sınıfın başka bir sınıftan miras almasıydı. Ancak bu durumda, temel olarak bir sınıftan miras alınan bir örnektir. Yani bu çok farklı ve bu yüzden bunu aklınızda tutun ya da belki notlarınıza ekleyin. Tamam mı? Artık nesnelerin bağlantılı prototip nesneye davranış devrettiğini de söyleyebiliriz. Ve davranış, burada yöntemler için kullanılan başka bir terimdir. Dolayısıyla, prototip kalıtımın yanı sıra, bu mekanizmaya delegasyon da diyoruz. Bu okun yukarıyı göstermesinin nedeni de budur çünkü teknik olarak nesneler davranışlarını prototipe devrederler. Öte yandan, sınıflı klasik OOP'de davranış, yani yöntemler aslında sınıftan nesneye kopyalanır ve bu tamamen farklıdır. Şimdi, burada tam terminoloji konusunda stres yapmanızı istemiyorum, tamam mı? Bu yüzden bunun çok fazla yeni şey, yani çok fazla yeni kelime ve yeni kavram olduğunu biliyorum. Ancak bu sadece çok net bir resim çizmek ve size tam bir genel bakış sağlamak içindir. Benim için önemli olan, prototip kalıtımın gerçekte nasıl çalıştığını anlamanızdır. Çünkü bir sonraki derste bunu pratikte kullanmaya başladığımızda, amaçlandığı gibi çalıştığı sürece miras ya da delegasyon olarak adlandırılması gerçekten önemli olmayacak, değil mi? Ancak bu kursa JavaScript'te işlerin gerçekte nasıl yürüdüğünü öğrenmek için geldiğinizden, size tüm bu bilgileri burada veriyorum. Şimdilik biraz fazla görünse de, eninde sonunda faydalı bulacağınızdan eminim. Aslında, JavaScript'te prototipleri gerçekten uyguladıktan sonra bu diyagrama geri döneceğiz ve biraz daha ayrıntıyla dolduracağız. Yani pratikte nasıl çalıştıklarını gördükten sonra. Ve o zamana kadar eminim ki tüm bunlar size %100 anlamlı gelecektir. Her neyse, aslında bu mekanizmanın işlediğini daha önce birçok kez gördük, ancak bunun gerçekleştiğini bilmiyorduk. Örneğin, map gibi bir dizi metodunu her kullandığımızda, prototipal kalıtım sayesinde bu metodu kullanabiliyoruz. Dolayısıyla, herhangi bir dizi yönteminin belgelerini kontrol etmek için MDN'ye gittiğinizde, orada göreceğiniz şey aslında dizi olarak adlandırıldığıdır. prototip. Harita. Ama bunun konuyla ne ilgisi var? Peki, bu ne anlama geliyor? Pekala, dizi. prototype, JavaScript'te oluşturduğumuz tüm dizilerin prototip nesnesidir. Yani, tıpkı num adlı bu örnek dizi gibi. Şimdi bu prototip nesne, map dahil olmak üzere tüm dizi yöntemlerini içerir. Yani, aslında tanımlandıkları yer burasıdır. Yani, diziden beri. prototipi num dizisinin prototipidir, bu num'un bu prototipe bağlı olduğu anlamına gelir. Bu nedenle, dizi üzerinde tanımlanan tüm yöntemlere erişebilir. prototip nesnesi, tıpkı map yöntemi gibi. Yani, bir anlamda, dizimiz map yöntemini miras alır. Ya da yine, dizinin eşleme davranışını prototipine devrettiğini de söyleyebiliriz. Dolayısıyla, aklınıza hangisi daha mantıklı geliyorsa onu seçebilirsiniz. Ancak önemli olan, map yönteminin aslında num dizisinin kendisi üzerinde değil, prototipi üzerinde tanımlanmış olmasıdır. Ve elbette, bu davranışı cout'umuzda da kontrol edeceğiz ve uygulayacağız, tamam mı? Şu anda kafanızda bir sürü soru olabilir. Mesela, prototipleri nasıl oluşturacağız? Ve nesneleri prototiplere nasıl bağlarız? Ve nesneleri örnekleyebileceğimiz sınıflar olmadan nasıl yeni nesneler oluşturabiliriz? Özetle, soru şu: JavaScript'te Nesne Yönelimli Programlamayı pratikte nasıl uygulayacağız? JavaScript'te tüm bunları yapmanın aslında üç farklı yolu vardır: kurucu fonksiyon tekniği, ES6 sınıfları ve ayrıca Object. create(). İlk olarak, kurucu işlevler, yeni nesnenin prototipini de ayarlayacak bir işlev kullanarak programlı olarak nesne oluşturmanın bir yoludur. Ve bu aslında diziler, haritalar veya kümeler gibi yerleşik nesnelerin nasıl uygulandığıdır. Ayrıca, JavaScript'te OOP temelde en başından beri bu şekilde yapılmaktadır. Ardından, ES6 sürümü JavaScript'e sınıfları dahil etti. Ve şimdi, ES6 sınıfları aslında JavaScript'te OOP yapmanın daha modern bir yoludur. Ancak, bunların aslında son derste ve son slaytta bahsettiğimiz türden sınıflar olmadığını unutmayın. Bunun yerine, yapıcı işlevler üzerinde 'sentetik şeker' olarak adlandırılırlar. Yani bu, ES6 sınıflarının temelde kurucu işlevler üzerinde bir engel katmanı olduğu anlamına gelir. Yani, yeni başlayanların JavaScript'te OOP yapmasını kolaylaştıran daha hoş bir sözdizimidir. Ancak perde arkasında, ES6 sınıfları aslında yapıcı işlevlerle uygulanmaktadır. Ve böylece son slaytta öğrendiğimiz gibi prototip kalıtımını da kullanırlar. Son olarak, bir de nesne var. create() işlevi, temelde bir nesneyi bir prototip nesneye bağlamanın en kolay ve en basit yoludur. Ancak, önümüzdeki birkaç derste göreceğimiz gibi, diğer iki yöntem kadar kullanılmamaktadır. Şimdi, bitirirken aklımızda tutmamız gereken önemli bir nokta, son derste öğrendiğimiz Nesne Yönelimli Programlamanın dört ilkesinin, yani engelleme, kapsülleme, kalıtım ve çok biçimliliğin, prototip kalıtım ile hala geçerli ve önemli olduğudur. Ve bu bölüm boyunca, elbette bu ilkeleri nasıl kullanacağımızı ve uygulayacağımızı öğreneceğiz. Pekala. Tüm bunları söyledikten sonra, şimdi nihayet OOP'yi uygulamaya koyalım ve biraz daha teknik konulara girelim.

