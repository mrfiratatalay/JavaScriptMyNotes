'use strict';
//////////////////////////////////
//Prototypal Inheritance and The Prototype Chain
//SLAYTLARI ACIP OKU, BURAYI..
/*
Jonas: Şimdi son iki videoda edindiğimiz bilgileri, şimdiye kadar bildiğimiz her şeyi bir araya getiren güzel bir diyagramda birleştirelim. Ve her şey geliştirmekte olduğumuz kurucu işlevle başlar. Şimdi, bu kurucu fonksiyonun bir nesne olan bir prototip özelliği vardır ve bu nesnenin içinde calcAge yöntemini tanımladık ve person nokta prototipinin kendisi de aslında kurucu özellik olan person'a bir referansa sahiptir. Yani, esasen person nokta prototip nokta kurucusu person'ın kendisine geri dönecektir. Şimdi hatırlayın, person nokta prototipi aslında person'ın değil, person fonksiyonu aracılığıyla oluşturulan tüm nesnelerin prototipidir ve oluşturulan nesnelerden bahsetmişken, şimdi new operatörü ve kurucu fonksiyonu kullanılarak bir nesnenin nasıl oluşturulduğunu inceleyelim. Dolayısıyla, bir fonksiyonu çağırdığımızda, new operatörüne sahip herhangi bir fonksiyon, gerçekleşecek ilk şey anında yeni bir boş nesnenin yaratılmasıdır. Ardından bu klavye ve işlev çağrısı yeni oluşturulan nesneye ayarlanır. Dolayısıyla, işlevin yürütme bağlamı içinde bu artık yeni boş nesnedir ve bu nedenle işlev kodunda this anahtar sözcüğünde ad ve doğum yılı özelliklerini ayarlıyoruz çünkü bunu yapmak sonuçta onları yeni nesneye ayarlayacaktır. Sırada sihirli adım var. Şimdi yeni nesne, yapıcı fonksiyonların prototip özelliğine bağlanmıştır. Yani bu durumda, kişi nokta prototipi. Ve bu, yeni nesneye alt çizgi, alt çizgi protal özelliği eklenerek dahili olarak gerçekleşir. Dolayısıyla, kişi nokta prototipi artık Jonas'ın alt çizgi, alt çizgi proto özelliğinde gösterilen yeni nesne prototipidir. Bu nedenle, alt çizgi proto her zaman bir nesne prototipine işaret eder ve bu JavaScript'teki tüm nesneler için geçerlidir. Harika. Ve son olarak, açıkça başka bir şey döndürmediğimiz sürece yeni nesne fonksiyondan otomatik olarak döndürülür. Ancak person gibi bir kurucu işlevde genellikle bunu asla yapmayız. Tamam, new operatörünün ve person constructor fonksiyonunun sonucu programatik olarak oluşturduğumuz ve Jonas değişkeninde depolanan yeni bir nesnedir ve az önce açıkladığım tüm bu süreç, fonksiyon kurucuları ve ES6 sınıfları ile nasıl çalıştığıdır, ancak daha sonra kullanacağımız object dot create sözdizimi ile değil. 

Dolayısıyla, nesne nokta oluşturma derslerini okuduğumuzda bunu aklınızda tutun. Her neyse, bu neden bu şekilde çalışıyor ve bu teknik neden bu kadar güçlü ve yararlı? ve bunu cevaplamak için bir sonraki kod satırına geçelim. Yani, burada jonas nesnesi üzerinde calcAge fonksiyonunu çağırmaya çalışıyoruz. Ancak, JavaScript aslında calcAge işlevini doğrudan jonas nesnesinde bulamaz, değil mi? Basitçe orada değil ve bu davranışı son derste zaten gözlemledik. Hatırladın mı? Peki, bu durumda şimdi ne olacak? Eğer bir özellik ya da metot belirli bir nesnede bulunamazsa JavaScript onun prototipine bakar ve işte oradadır. İşte aradığımız calcAge fonksiyonu burada ve JavaScript basitçe bunu kullanacak. Bu şekilde calcAge fonksiyonu doğru şekilde çalışabilir ve bir sonuç döndürebilir. Ve az önce tanımladığımız davranış, prototip kalıtım veya delegasyon olarak adlandırdığımız şeydir. Yani jonas nesnesi calcAge yöntemini prototipinden miras almıştır ya da başka bir deyişle calcAge işlevini prototipine devretmiştir. Şimdi, bunun güzelliği, istediğimiz kadar kişi nesnesi oluşturabilmemiz ve hepsinin bu yöntemi miras alacak olmasıdır. Böylece bu calcAge yöntemini, yöntem doğrudan tüm nesnelerin kendilerine bağlı olmadan tüm kişi nesneleri üzerinde çağırabiliriz ve bu, kod performansı için çok önemlidir. Kodda 1.000 nesnemiz olduğunu ve bunların hepsinin calcAge işlevini taşımak zorunda kalacağını düşünün, bu kesinlikle performansı etkileyecektir. Bunun yerine, hepsi ortak prototiplerinden calcAge işlevini kullanabilir, tamam mı? Yani bu mantıklı, değil mi? Şimdi Jonas'ın bir prototipe bağlı olması ve bir prototipte yöntem ve özelliklere bakma yeteneği, prototip zinciri dediğimiz şeydir.

 Yani jonas nesnesi ve prototipi temelde bir prototip zinciri oluşturur ama aslında prototip zinciri burada bitmez. Şimdi prototip zincirini biraz daha yakınlaştırarak ve resmin tamamına bakarak daha iyi anlayalım. İşte, fonksiyon kurucusu ve prototip özelliği ile prototipine alt çizgi proto özelliği aracılığıyla bağlanan jonas nesnesi ile zaten sahip olduğumuz diyagram, yani henüz yeni bir şey yok. Ama şimdi nokta prototipinin kendisinin de bir nesne olduğunu ve JavaScript'teki tüm nesnelerin bir prototipi olduğunu hatırlayalım, değil mi? Bu nedenle, kişi nokta prototipinin kendisinin de bir prototipi olmalıdır. Kişi nokta prototipinin prototipi ise nesne nokta prototipidir. Nedenmiş o? Kişi nokta prototipi sadece basit bir nesnedir, bu da yerleşik nesne kurucu işlevi tarafından oluşturulduğu anlamına gelir ve bu aslında bir nesne değişmezi oluşturduğumuzda perde arkasında çağrılan işlevdir. Yani sadece küme parantezleri olan bir nesne. Yani aslında küme parantezleri yeni nesne yazmak için bir kısayol gibidir, tamam mı? Ancak her neyse, burada önemli olan nokta prototipinin kendisinin bir prototipe sahip olması gerektiğidir ve nesne kurucu işlevi tarafından oluşturulduğu için prototipi nesne nokta prototipi olacaktır. Jonas nesnesi ile aynı mantık. Jonas bir kişi tarafından inşa edildiğine göre, kişi nokta prototipi Jonas'ın prototipidir, tamam mı? Nesneler arasındaki tüm bu bağlantı dizisine prototip zinciri adı verilir ve nokta prototip nesnesi genellikle prototip zincirinin en üstünde yer alır, bu da prototipinin boş olduğu anlamına gelir. Dolayısıyla, alt çizgi proto özelliği basitçe null değerini gösterecek ve bu da prototip zincirinin sonunu işaret edecektir. Dolayısıyla prototip zinciri bir bakıma kapsam zincirine çok benzemektedir ancak prototipler söz konusudur. Dolayısıyla, kapsam zincirinde JavaScript belirli bir kapsamdaki belirli bir değişkeni bulamadığında, bir sonraki kapsama ve kapsam zincirine bakar ve değişkeni orada bulmaya çalışır. Öte yandan, prototip zincirinde JavaScript belirli bir nesnede belirli bir özellik veya yöntem bulduğunda, prototip zincirindeki bir sonraki prototipe bakacak ve onu orada bulup bulamayacağına bakacaktır, tamam mı? Yine prototip zinciri kapsam zincirine oldukça benzer ancak kapsamlarla çalışmak yerine nesnelerdeki özellikler ve yöntemlerle çalışır, tamam mı? Şimdi de başka bir yöntem arama örneği görelim.
  Bunu yapmak için jonas nesnesi üzerinde has own property metodunu çağırıyoruz. Dolayısıyla, önceki slaytta olduğu gibi, JavaScript çağrılan yöntemi nesnenin kendisinde bulmaya çalışarak başlayacaktır. Ancak elbette Jonas'ta kendi mülküne sahip olma yöntemini bulamıyor. Dolayısıyla, prototip zincirinin nasıl çalıştığına göre, daha sonra kişi nokta prototipi olan prototipine bakacaktır. Şimdi, orada da herhangi bir has own property yöntemi tanımlamadık ve bu nedenle bir JavaScript bunu orada bulamayacak ve bu nedenle prototip zincirinde daha da yukarı çıkacak ve şimdi object dot prototype'a bakın ve object dot prototype aslında bir grup yerleşik yöntem içerir ve has own property bunlardan biridir. Harika, JavaScript bunu alıp jonas nesnesi üzerinde, sanki kendi özelliği doğrudan Jonas üzerinde tanımlanmış gibi çalıştırabilir. Ve yöntemin jonas nesnesine kopyalanmadığını unutmayın. Bunun yerine, yöntemi prototip zinciri aracılığıyla object dot prototype'dan miras almıştır. Tamam, aslında bu kadar. Bu noktada size söyleyeceklerim bu kadar. İşte prototiplerin ve prototip zincirinin büyüsü özetle budur. Ve bu aslında iki farklı nesne türü veya iki farklı sınıf arasında kalıtım eklediğimizde daha da ilginç ve kullanışlı hale gelecektir. Örneğin, bir öğrenci sınıfının bir kişi sınıfından miras alması, tıpkı OOP'nin dört temel direğinden birinde öğrendiğimiz gibi, hatırlayın. Önümüzde heyecan verici pek çok şey var, o yüzden devam edelim.

*/

///////////////////////////////////////
// Prototypal Inheritance on Built-In Objects
console.log(jonas.__proto__);
// Object.prototype (top of prototype chain)
console.log(jonas.__proto__.__proto__);
console.log(jonas.__proto__.__proto__.__proto__);

console.dir(Person.prototype.constructor);

const arr = [3, 6, 6, 5, 6, 9, 9]; // new Array === []
console.log(arr.__proto__);
console.log(arr.__proto__ === Array.prototype);

console.log(arr.__proto__.__proto__);

Array.prototype.unique = function () {
  return [...new Set(this)];
};

console.log(arr.unique());

const h1 = document.querySelector('h1');
console.dir(x => x + 1);

/*
Şimdi prototip kalıtımı ve diziler gibi yerleşik nesneler üzerindeki prototip zincirini inceleyelim. Ama aslında bu derse son derste konuştuğumuz bazı şeyleri inceleyerek başlayalım. Ve oluşturmakta olduğumuz bu kişi örneğini kullanmaya devam edeceğiz. Jonas'a bir göz atarak başlayalım. _ _ proto Ve zaten bunun tam olarak kişinin prototip özelliği olan Jonas'ın prototipi olduğunu biliyoruz. Dolayısıyla, daha önce tanımladığımız Saat H-yöntemini içeren bu nesnedir. Yani burada ve ayrıca bu özellik, yani bu tür özelliği, ama şimdi aslında prototip zincirinde yukarı çıkalım ve esasen Jonas'ın prototipinin prototipine bir göz atalım. Son videodan bunun ne olacağını hatırlıyor musunuz? Pekala, bir bakalım. Ve gerçekten de nesnenin prototip özelliğidir. İşte bu yüzden kurucunun burada nesne olduğunu görebilirsiniz. Ve hemen ardından, aslında son videoda zaten çalıştığımız bu yöntemi görüyoruz. Yani bunun kendi mülkiyeti var. İşte bu yüzden bunu yapabiliyoruz. Öyleyse neden daha önceki videolardan birinde yaptığımız gibi Jonas'ta kendi mülkümüz var diyebiliriz. Son derste bunun prototip zinciri sayesinde ve özellikle de bu yöntem Jonas'ın prototipinin bu prototipinde yer aldığı için işe yaradığını öğrenmiştik. Ve evet, şu anda incelediğimiz nesne bu. Tamam. Tamam, ama bunu bir adım daha ileri götürelim ve prototipin prototipinin prototipine göz atalım. Bunun ne olduğunu hatırlıyor musun? Bu doğru. Hayır. İşte bu yüzden nesne. prototip genellikle kapsam zincirinin en üstünde yer alır. Yani buradaki, değil mi? Yani bu bir itiraz olacak. prototip. Bu da prototip zincirinin en tepesi. Tamam. Şimdi daha önce gördüğümüz o garip kurucu özelliğine de bir göz atabiliriz. Unutmayın. prototipinin kendisinin, söylediğimiz gibi, kişinin kendisini işaret edecek bir kurucu özelliği vardır.
 Yani kurucu, bunun gibi. Ve burada aslında fonksiyonun kendisini elde ediyoruz. Şimdi, bu fonksiyonu burada incelemek istiyorsak console kullanmamız gerekir. dir Ve burada, gerçekten de kurucu özelliğinin person'ı işaret ettiğini görüyoruz. İşte bu. Şimdi işleri biraz daha karmaşık hale getirmek için, şimdi bir fonksiyonun prototipine bir göz atalım. Dolayısıyla herhangi bir fonksiyon da elbette bir nesnedir. Dolayısıyla bir prototipi de var ama belki bu biraz fazla kafa karıştırıcı olabilir. O yüzden burada bırakalım. Bu yüzden size önce dizilerin prototipini göstereceğim ve belki daha sonra fonksiyonlara geçebiliriz. Aslında bunu şimdi yapalım. O halde tıpkı rastgele sayılarda olduğu gibi bir dizi oluşturalım. Yani buradaki değerler hiç önemli değil. Şu anda ilgilendiğim tek şey proto özelliğine bir göz atmak. Yani dizinin prototipi. Bakalım. Ve işte burada. 
 Bu, dizinin prototipidir ve burada zaten bildiğimiz tüm bu yöntemlere sahip olduğumuzu görüyorsunuz. Dolayısıyla doldurma, filtreleme, bulma, indeks bulma ve daha önceki bölümlerden birinde incelediğimiz tüm bu yöntemlere sahibiz. İşte tüm dizilerin bu yöntemlerin tümüne erişebilmesinin nedeni budur. Dolayısıyla, her dizi elbette bu yöntemlerin tümünü içermez, bunun yerine her dizi bu yöntemleri kendi prototipinden miras alır. Haksız mıyım? Ayrıca bu prototipin tam olarak yapıcı fonksiyon olan dizi olması gerektiğini de kontrol edebiliriz. prototip. Bir kez daha, yapıcının prototip özelliği, bu yapıcı tarafından oluşturulan tüm nesnelerin prototipi olacaktır. Bakalım, bu gerçekten de doğru. Ve tıpkı bir nesnenin bu kısaltmayı kullanması gibi, temelde , new array kullanmakla aynı şeydir. Bu nedenle, bunun gibi bir dizi oluşturduğumuzda, dizi gerçekten de dizi kurucusu tarafından oluşturulur. İşte bu yüzden tüm bunlar perde arkasında çalışıyor.
  Ancak elbette bu, son videoda gördüğümüz gibi henüz prototip zincirinin sonu değil. Bakalım. Ve şimdi nesne nokta prototipine geri dönüyoruz. Ve görüyorsun. Bu da artık on özelliğine ve ardından nesneler için kullanılabilen tüm bu yöntemlere sahiptir. Ve bir kez daha, bunun nedeni prototipin kendisinin burada bir nesne olmasıdır. Ve böylece herhangi bir nesne bu yöntemlerin tümüne erişebilir. Pekala, şimdi aynı şeyi doğrudan konsolda da görebileceğiz. Eğer buradaki diziyi kontrol edip açarsam, alt kısımda prototip özelliğimizin olduğunu göreceksiniz. Eğer buna tıklarsak, burada bir kez daha zaten bildiğimiz tüm bu dizi yöntemlerini elde ederiz. Tamam. Örneğin filtre için MDN'deki belgeleri kontrol edersek, aslında yöntemin adının dizi olduğunu görürsünüz. prototip. Filtre. Bunun nedeni, bu filtre yönteminin elbette dizi kurucusunun prototip özelliğinde yer almasıdır. Böylece bir kez daha prototip kalıtımın gerçekten kodu yeniden kullanmak için bir mekanizma olduğunu görebilirsiniz. Dolayısıyla, buradaki tüm bu yerleşik yöntemlerin JavaScript motorunda bir yerde yalnızca bir kez bulunması gerekir ve ardından kodumuzdaki tüm diziler prototip zinciri ve prototip kalıtımı yoluyla işlevlere erişir. Harika.
   Aslında bunu bir adım daha ileri götürelim. Bu noktada, herhangi bir dizinin tüm yöntemlerini bir prototipten miras aldığını biliyoruz. Dolayısıyla bu bilgiyi dizilerin işlevselliğini daha da genişletmek için kullanabiliriz. Yani tek yapmamız gereken dizi demek. prototip. Ve sonra burada bu prototipe herhangi bir yeni yöntem ekleyebiliriz ve tüm diziler bunu miras alacaktır. Diyelim ki bir dizinin tüm benzersiz öğelerini döndüren bir yöntem oluşturmak istedik. Öyleyse unique adında bir yöntem ekleyelim. Böylece unique özelliğini bir fonksiyona ayarlarız ve sonra bir dizinin unique değerlerini almak için tek yapmamız gereken yeni bir set oluşturmak ve diziyi buraya aktarmaktır. Ve bu klavye, bu yöntemin çağrılacağı dizi olacaktır. Ve şimdi bunu bir diziye koymamız ve daha önce birçok kez yaptığımız gibi bu şekilde yaymamız gerekiyor. Artık bunu kullanabiliriz. Yani dizi. benzersizdir ve bu artık yalnızca benzersiz değerleri içeren bir dizi döndürmelidir. Burada çok fazla mükerrerimiz olmasa da buraya altı tane daha ekleyelim ve belki dokuz tane daha. Bakalım neler olacak ve gerçekten de işe yaradı mı? Çok güzel. Özetlemek gerekirse, dizi kurucusunun prototype özelliğine yeni bir yöntem ekledik. Bu nedenle artık tüm diziler bu yöntemi miras alacaktır.
    Ve böylece bu yöntemi istediğimiz herhangi bir dizi üzerinde çağırabiliriz. Ancak, burada yaptığımız şey. Bu nedenle, yerleşik bir nesnenin prototipini genişletmek genellikle iyi bir fikir değildir. Demek istediğim, kendi başınıza küçük bir proje üzerinde çalışıyorsanız, sanırım bunu yapabilirsiniz, ancak gerçekten birden fazla nedenden dolayı bunu yapma alışkanlığı edinmeyin. İlk neden, JavaScript'in bir sonraki sürümünün bizim eklediğimiz adla aynı ada sahip bir yöntem ekleyebileceği, örneğin buradaki gibi, ancak farklı bir şekilde çalışabileceğidir. Böylece kodunuz farklı şekilde çalışan bu yeni yöntemi kullanacaktır. Ve bu muhtemelen kodunuzu bozacaktır. Bunu yapmamanızın ikinci nedeni ise, geliştiricilerden oluşan bir ekiple çalışıyorsanız, bu gerçekten kötü bir fikir olacaktır çünkü birden fazla geliştirici aynı yöntemi farklı bir adla uygularsa, bu o kadar çok hata yaratacaktır ki bunu yapmaya değmez. Bu sadece güzel ve eğlenceli bir deney ama pratikte muhtemelen bunu yapmamalısınız. Şimdi bu videoyu bitirmek için biraz eğlenelim. Konsolda bulunan bazı yerleşik nesnelere daha göz atalım. Örneğin, bu DOM öğesini buradan seçebiliriz. Ve bunu yapalım. Bu H1. Yani bu bir belge. querySelector H1 ve tüm DOM öğelerinin perde arkasındaki nesneler olduğunu zaten biliyoruz. Şimdi bu nesneye bir göz atalım. Bu pek işe yaramıyor. Yani bu bize sadece nesneyi verir. Öyleyse bir konsol deneyelim. Bu H1'de. Ve şimdi gerçek nesneyi alıyoruz.
     Yani burada tüm bu farklı şeylere ve zaten çalıştığımız tüm bu özelliklere ve yöntemlere sahibiz. Ancak burada ilgilendiğim şey prototip ve prototipin bir HTML başlık öğesi olduğunu görüyorsunuz. Tamam mı? Ve bu yüzden bir kez daha birçok farklı şey içerecektir. O zaman aşağıya doğru kaydıralım. Ve böylece bu artık bir HTML öğesidir. Peki bu isimleri bir yerlerden hatırlıyor musunuz? Bunlar tam olarak DOM bölümündeki ilk derslerden birinde bahsettiğimiz nesne türleridir. Hatırladın mı? Elimizde tüm bu farklı unsur türlerini içeren büyük bir diyagram vardı. Ve şimdi burada onları gerçekten inceleyebiliriz. Ve böylece perde arkasında bu farklı öğeler kurucu işlevler gibi gerçekten farklıdır. Eğer buraya inersek şimdi elementi görmemiz gerekir ve gerçekten de işte burada. Ve yine orada incelediğimiz diyagramı hatırlayabilirsiniz. Ve sonra HTML öğesinin öğenin bir alt öğesi olduğunu ve öğenin kendisinin de düğümün bir alt öğesi olduğunu hatırlayacaksınız, değil mi? Bu nedenle elementin prototipi node olacaktır. Buraya kadar kaydırırsak, gerçekten de düğüm görürsünüz ve şimdi bu olay hedefidir. Göreceğiniz üzere, bu çok ama çok büyük bir prototip zinciri. Ve ancak şimdi sonuna geldik. Ve böylece son bir nesnedir ve hepsi bu. Yani bu prototip zincirin kolaylıkla altı ya da yedi seviyesi var. Ve böylece bunun gerçekten çok derinlere inebileceğini görüyorsunuz. Eğer gidip bunu kendi başınıza kontrol etmek isterseniz, bu muhtemelen gerçekten güzel bir egzersiz olacaktır. Ve son olarak, bir de teselli edelim. dir bazı rastgele fonksiyonlar. Yani işlev önemli değil. Sadece fonksiyona bakabilmek istiyorum. Tamam. Dolayısıyla, bu videoda biraz önce bahsettiğim gibi, fonksiyonun kendisi de bir nesnedir. Bu nedenle de bir prototipi vardır. Ve bu durumda prototip, daha önce fonksiyonlar üzerinde kullandığımız yöntemleri içerecektir. Yani uygula, bağla ve ara, unutma. İşte bir kez daha fonksiyonlar üzerinde metot çağırabilmemizin nedeni budur. Çünkü onlar nesnedir ve nesnelerin prototipleri vardır. Ve bu durumda, bu fonksiyon prototipi. Dolayısıyla, tüm bunları keşfetmekle gerçekten ilgileniyorsanız çok daha fazla zaman harcayabilirsiniz. Ancak önceki tüm dersleri iyi bir şekilde anladığınızı düşündüğünüzde, bu bölümün ilk kodlama mücadelesi olacak olan bir sonraki videoya geçebilirsiniz.
*/
